#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set et ai sta sw=2 ts=2 tw=0:
"""
LiLo for BootSetup.
"""
__copyright__ = 'Copyright 2013-2014, Salix OS'
__license__ = 'GPL2+'

import tempfile
import shutil
import os
import glob
import salix_livetools_library as sltl
import subprocess

class Lilo:
  
  isTest = False
  _prefix = None
  _tmp = None
  _mbrDevice = None
  _bootPartition = None
  _partitions = None
  _bootInBootMounted = False
  _cfgTemplate = """# LILO configuration file
# Generated by BootSetup
#
# Start LILO global section
# Append any additional kernel parameters:
append = "vt.default_utf8=1 "
boot = {boot}
lba32
compact

# Boot BMP Image.
# Bitmap in BMP format: 640x480x8
bitmap = {mp}/boot/salix.bmp
# Menu colors (foreground, background, shadow, highlighted
# foreground, highlighted background, highlighted shadow):
bmp-colors = 255,20,255,20,255,20
# Location of the option table: location x, location y, number of
# columns, lines per column (max 15), "spill" this is how many
# entries must be in the first column before the next begins to
# be used.  We do not specify it here, as there is just one column.
bmp-table = 60,6,1,16
# Timer location x, timer location y, foreground color,
# background color, shadow color.
bmp-timer = 65,29,0,255

# Standard menu.
# Or, you can comment out the bitmap menu above and 
# use a boot message with the standard menu:
# message = /boot/boot_message.txt

# Wait until the timeout to boot (if commented out, boot the
# first entry immediately):
prompt
# Timeout before the first entry boots.
# This is given in tenths of a second, so 600 for every minute:
timeout = 50
# Override dangerous defaults that rewrite the partition table:
change-rules
reset

# Normal VGA console
# vga = normal
vga = {vga}
# End LILO global section
#
# BootSetup can be executed from a LiveCD. This means that lilo
# could be issued from a 'chrooted' Linux partition, which would
# happen to be the first Linux partition listed below.
# Therefore the following paths are relevant only when viewed
# from that 'chrooted' partition's perspective. Please take this
# constraint into consideration if you must modify this file
# or else BootSetup will fail.
#
# If later on you want to use this configuration file directly
# with lilo in a command line, use the following syntax:
# "lilo -v -C /etc/bootsetup/lilo.conf" instead of the traditional
# "lilo -v" command. You must of course issue that command from
# the operating system holding /etc/bootsetup/lilo.conf and ensure that
# all partitions referenced in it are mounted on the appropriate
# mountpoints.
"""

  def __init__(self, isTest):
    self.isTest = isTest
    self._prefix = "bootsetup.lilo-"
    self._tmp = tempfile.mkdtemp(prefix = self._prefix)
    sltl.mounting._tempMountDir = os.path.join(self._tmp, 'mounts')
    self.__debug("tmp dir = " + self._tmp)

  def __del__(self):
    if self._tmp and os.path.exists(self._tmp):
      self.__debug("cleanning " + self._tmp)
      try:
        cfgPath = self.getConfigurationPath()
        if os.path.exists(cfgPath):
          self.__debug("Remove " + cfgPath)
          os.remove(cfgPath)
        if os.path.exists(sltl.mounting._tempMountDir):
          self.__debug("Remove " + sltl.mounting._tempMountDir)
          os.rmdir(sltl.mounting._tempMountDir)
        self.__debug("Remove " + self._tmp)
        os.rmdir(self._tmp)
      except:
        pass

  def __debug(self, msg):
    if self.isTest:
      print "Debug: " + msg

  def getConfigurationPath(self):
    return os.path.join(self._tmp, "lilo.conf")

  def _mountBootPartition(self):
    """
    Return the mount point
    """
    self.__debug("bootPartition = " + self._bootPartition)
    if sltl.isMounted(self._bootPartition):
      self.__debug("bootPartition already mounted")
      return sltl.getMountPoint(self._bootPartition)
    else:
      self.__debug("bootPartition not mounted")
      return sltl.mountDevice(self._bootPartition)

  def _mountBootInBootPartition(self, mountPoint):
    # assume that if the mount_point is /, any /boot directory is already accessible/mounted
    if mountPoint != '/' and os.path.exists(os.path.join(mountPoint, 'etc/fstab')):
      self.__debug("mp != / and etc/fstab exists, will try to mount /boot by chrooting")
      try:
        self.__debug("grep -q /boot {mp}/etc/fstab && chroot {mp} /sbin/mount /boot".format(mp = mountPoint))
        if sltl.execCall("grep -q /boot {mp}/etc/fstab && chroot {mp} /sbin/mount /boot".format(mp = mountPoint)):
          self.__debug("/boot mounted in " + mp)
          self._bootInBootMounted = True
      except:
        pass

  def _mountPartitions(self, mountPointList):
    """
    Fill a list of mount points for each partition
    """
    if self._partitions:
      self.__debug("mount partitions: " + str(self._partitions))
      for p in self._partitions:
        dev = os.path.join("/dev", p[0])
        self.__debug("mount partition " + dev)
        mp = sltl.mountDevice(dev)
        if mp:
          mountPointList.append(mp)
        else:
          raise Exception("Cannot mount {d}".format(d = dev))

  def _umountAll(self, mountPoint, mountPointList):
    self.__debug("umountAll")
    if mountPoint:
      self.__debug("umounting main mount point " + mountPoint)
      if self._bootInBootMounted:
        self.__debut("/boot mounted in " + mountPoint + ", so umount it")
        sltl.execCall("chroot {mp} /sbin/umount /boot".format(mp = mountPoint))
        self._bootInBootMounted = False
      if mountPointList:
        self.__debug("umount other mount points: " + str(mountPointList))
        for mp in mountPointList:
          self.__debug("umount " + str(mp))
          sltl.umountDevice(mp)
      if mountPoint != '/':
        self.__debug("main mount point ≠ '/' → umount " + mountPoint)
        sltl.umountDevice(mountPoint)

  def _createLiloSections(self, mountPointList):
    """
    Return a list of lilo section string for each partition.
    There could be more section than partitions if there are multiple kernels.
    """
    sections = []
    if self._partitions:
      for e in enumerate(self._partitions):
        i = e[0]
        p = e[1]
        mp = mountPointList[i]
        device = os.path.join("/dev", p[0])
        fs = p[1]
        bootType = p[2]
        label = p[3]
        if bootType == 'chain':
          sections.append(self._getChainLiloSection(device, label))
        elif bootType == 'linux':
          sections.extend(self._getLinuxLiloSections(device, fs, mp, label))
        else:
          sys.err.write("The boot type {type} is not supported.\n".format(type = bootType))
    return sections

  def _getChainLiloSection(self, device, label):
    """
    Returns a string for a chainloaded section
    """
    self.__debug("Section 'chain' for " + device + " with label: " + label)
    return """# {label} chain section
  other = {device}
  label = {label}
""".format(device = device, label = label)

  def _getLinuxLiloSections(self, device, fs, mp, label):
    """
    Returns a list of string sections, one for each kernel+initrd
    """
    sections = []
    self.__debug("Section 'linux' for " + device + "/" + fs + ", mounted on " + mp + " with label: " + label)
    kernelList = sorted(glob.glob("{mp}/boot/vmlinuz*".format(mp = mp)))
    initrdList = sorted(glob.glob("{mp}/boot/initr*".format(mp = mp)))
    for l in (kernelList, initrdList):
      for el in l:
        if os.path.isdir(el) or os.path.islink(el):
          l.remove(el)
    self.__debug("kernelList: " + str(kernelList))
    self.__debug("initrdList: " + str(initrdList))
    uuid = sltl.execGetOutput(['/sbin/blkid', '-s', 'UUID', '-o', 'value', device], shell = False)
    if uuid:
      rootDevice = "/dev/disk/by-uuid/{uuid}".format(uuid = uuid[0])
    else:
      rootDevice = device
    self.__debug("rootDevice = " + rootDevice)
    for (k, i, l) in self._getKernelInitrdCouples(kernelList, initrdList, label):
      self.__debug("kernel, initrd, label found: " + str(k) + "," + str(i) + "," + str(l))
      section = None
      if i:
        section = """# {label} Linux section
  root = {root}
  image = {image}
  initrd = {initrd}
""".format(image = k, initrd = i, root = rootDevice, label = l)
      else:
        section = """# {label} Linux section
  root = {root}
  image = {image}
""".format(image = k, root = rootDevice, label = l)
      if fs == 'ext4':
        section += '  append = "{append} "\n'.format(append = 'rootfstype=ext4')
      section += "  read-only\n  label = {label}\n".format(label = l)
      sections.append(section)
    return sections

  def _getKernelInitrdCouples(self, kernelList, initrdList, labelRef):
    ret = []
    if kernelList:
      if len(kernelList) == 1:
        initrd = None
        if initrdList:
          initrd = initrdList[0] # assume the only initrd match the only kernel
        ret.append([kernelList[0], initrd, labelRef])
      else:
        labelBase = labelRef[0:15-2] + "-"
        n = 0
        for kernel in kernelList:
          n += 1
          kernelSuffix = os.path.basename(kernel).replace("vmlinuz", "")
          initrd = None
          for i in initrdList:
            if kernelSuffix in i: # find the matching initrd
              initrd = i
              break
          ret.append((kernel, initrd, labelBase + str(n)))
    return ret

  def _getFrameBufferConf(self):
    """
    Return the frame buffer configuration for this hardware.
    Format: (fb, label)
    """
    try:
      fbGeometry = sltl.execGetOutput("/usr/sbin/fbset | grep -w geometry")
    except subprocess.CalledProcessorError:
      self.__debug("Impossible to determine frame buffer mode, default to text.")
      fbGeometry = None
    mode = None
    label = None
    if fbGeometry:
      vesaModes = {
          4: {
            200: { 320: None },
            400: { 640: None },
            480: { 640: None },
            500: { 800: None },
            600: { 800: 770 },
            640: { 1024: None },
            672: { 896: None },
            720: { 1152: None },
            768: { 1024: 772 },
            800: { 1280: None },
            900: { 1440: None },
            1024: { 1280: 774 },
            1050: { 1400: None },
            1200: { 1600: None, 1920: None },
          },
          8: {
            200: { 320: None },
            400: { 640: 768 },
            480: { 640: 769 },
            500: { 800: 879 },
            600: { 800: 771 },
            640: { 1024: 874 },
            672: { 896: 815 },
            720: { 1152: 869 },
            768: { 1024: 773 },
            800: { 1280: 864 },
            900: { 1440: 864 },
            1024: { 1280: 775 },
            1050: { 1400: 796 },
            1200: { 1600: 796, 1920: 893 },
          },
          15: {
            200: { 320: 781 },
            400: { 640: 801 },
            480: { 640: 784 },
            500: { 800: 880 },
            600: { 800: 787 },
            640: { 1024: 875 },
            672: { 896: 816 },
            720: { 1152: 870 },
            768: { 1024: 790 },
            800: { 1280: 865 },
            900: { 1440: 865 },
            1024: { 1280: 793 },
            1050: { 1400: 797 },
            1200: { 1600: 797, 1920: 894 },
          },
          16: {
            200: { 320: 782 },
            400: { 640: 802 },
            480: { 640: 785 },
            500: { 800: 881 },
            600: { 800: 788 },
            640: { 1024: 876 },
            672: { 896: 817 },
            720: { 1152: 871 },
            768: { 1024: 791 },
            800: { 1280: 866 },
            900: { 1440: 866 },
            1024: { 1280: 794 },
            1050: { 1400: 798 },
            1200: { 1600: 798, 1920: 895 },
          },
          24: {
            200: { 320: 783 },
            400: { 640: 803 },
            480: { 640: 786 },
            500: { 800: 882 },
            600: { 800: 789 },
            640: { 1024: 877 },
            672: { 896: 818 },
            720: { 1152: 872 },
            768: { 1024: 792 },
            800: { 1280: 867 },
            900: { 1440: 867 },
            1024: { 1280: 795 },
            1050: { 1400: 799 },
            1200: { 1600: 799, 1920: 896 },
          },
          32: {
            200: { 320: None },
            400: { 640: 804 },
            480: { 640: 809 },
            500: { 800: 883 },
            600: { 800: 814 },
            640: { 1024: 878 },
            672: { 896: 819 },
            720: { 1152: 873 },
            768: { 1024: 824 },
            800: { 1280: 868 },
            900: { 1440: 868 },
            1024: { 1280: 829 },
            1050: { 1400: 834 },
            1200: { 1600: 834, 1920: 897 },
          }
        }
      values = fbGeometry[0].strip().split(' ')
      self.__debug("FB Values: " + str(values))
      xRes = int(values[1])
      yRes = int(values[2])
      deep = int(values[-1])
      xMax = None
      yMax = None
      if deep in vesaModes:
        for y in sorted(list(vesaModes[deep]), reverse = True):
          self.__debug("trying {0} for y".format(y))
          if y <= yRes:
            yMax = y
            break
        if yMax:
          for x in sorted(list(vesaModes[deep][yMax]), reverse = True):
            self.__debug("trying {0} for x".format(x))
            if x <= xRes:
              xMax = x
              break
      self.__debug("Max X×Y found: {x}×{y}".format(x = xMax, y = yMax))
      if xMax and yMax:
        mode = vesaModes[deep][yMax][xMax]
        label = "{x}x{y}x{d}".format(x = xMax, y = yMax, d = deep)
    if not mode:
      mode = 'normal'
      label = 'text'
    return (mode, label)

  def createConfiguration(self, mbrDevice, bootPartition, partitions):
    """
    partitions format: [device, filesystem, boot type, label]
    """
    self._mbrDevice = os.path.join("/dev", mbrDevice)
    self._bootPartition = os.path.join("/dev", bootPartition)
    self._partitions = partitions
    mp = None
    mpList = None
    try:
      mp = self._mountBootPartition()
      if not mp:
        raise Exception("Cannot mount the main boot partition.")
      self.__debug("mp = " + str(mp))
      self._mountBootInBootPartition(mp)
      mpList = []
      self._mountPartitions(mpList)
      self.__debug("mount point lists: " + str(mpList))
      liloSections = self._createLiloSections(mpList)
      self.__debug("lilo sections: " + str(liloSections))
      (fb, fbLabel) = self._getFrameBufferConf()
      self.__debug("frame buffer mode = " + str(fb) + " " + str(fbLabel))
      f = open(self.getConfigurationPath(), "w")
      f.write(self._cfgTemplate.format(boot = self._mbrDevice, mp = mp, vga = "{0} # {1}".format(fb, fbLabel)))
      for s in liloSections:
        f.write(s)
        f.write("\n")
      f.close()
    finally:
      self._umountAll(mp, mpList)

  def install(self):
    """
    Assuming that last configuration editing didn't modified mount point.
    """
    if self._mbrDevice:
      self._bootInBootMounted = False
      mp = None
      mpList = None
      try:
        mp = self._mountBootPartition()
        if not mp:
          raise Exception("Cannot mount the main boot partition.")
        self.__debug("mp = " + str(mp))
        self._mountBootInBootPartition(mp)
        if mp != "/":
          self.__debug("mount point ≠ / so mount /dev and /proc in it")
          # bind /dev and /proc in boot_partition
          sltl.execCall('mount -o bind /dev {mp}/dev'.format(mp = mp))
          sltl.execCall('mount -o bind /proc {mp}/proc'.format(mp = mp))
        mpList = []
        self._mountPartitions(mpList)
        self.__debug("mount point lists: " + str(mpList))
        # copy the configuration to the boot_partition
        try:
          self.__debug("create etc/bootsetup directory in " + mp)
          os.makedirs(os.path.join(mp, 'etc/bootsetup'))
        except os.error:
          pass
        self.__debug("copy lilo.conf to etc/bootsetup")
        shutil.copyfile(self.getConfigurationPath(), os.path.join(mp, '/etc/bootsetup/lilo.conf'))
        # run lilo
        if self.isTest:
          self.__debug('/sbin/lilo -t -v -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
          sltl.execCall('/sbin/lilo -t -v -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
        else:
          sltl.execCall('/sbin/lilo -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
      finally:
        if mp and mp != "/":
          self.__debug("mount point ≠ / so umount /dev and /proc in it")
          sltl.execCall('umount {mp}/proc'.format(mp = mp))
          sltl.execCall('umount {mp}/dev'.format(mp = mp))
        self._umountAll(mp, mpList)
