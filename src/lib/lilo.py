#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set et ai sta sw=2 ts=2 tw=0:
"""
LiLo for BootSetup.
"""
__copyright__ = 'Copyright 2013-2014, Salix OS'
__license__ = 'GPL2+'

import tempfile
import shutil
import os
import glob
import salix_livetools_library as sltl
import subprocess

class Lilo:
  
  isTest = False
  _prefix = None
  _tmp = None
  _mbrDevice = None
  _bootPartition = None
  _partitions = None
  _bootInBootMounted = False
  _cfgTemplate = """# LILO configuration file
# Generated by BootSetup
#
# Start LILO global section
# Append any additional kernel parameters:
append = "vt.default_utf8=1 "
boot = {boot}
lba32
compact

# Boot BMP Image.
# Bitmap in BMP format: 640x480x8
bitmap = {mp}/boot/salix.bmp
# Menu colors (foreground, background, shadow, highlighted
# foreground, highlighted background, highlighted shadow):
bmp-colors = 255,20,255,20,255,20
# Location of the option table: location x, location y, number of
# columns, lines per column (max 15), "spill" this is how many
# entries must be in the first column before the next begins to
# be used.  We do not specify it here, as there is just one column.
bmp-table = 60,6,1,16
# Timer location x, timer location y, foreground color,
# background color, shadow color.
bmp-timer = 65,29,0,255

# Standard menu.
# Or, you can comment out the bitmap menu above and 
# use a boot message with the standard menu:
# message = /boot/boot_message.txt

# Wait until the timeout to boot (if commented out, boot the
# first entry immediately):
prompt
# Timeout before the first entry boots.
# This is given in tenths of a second, so 600 for every minute:
timeout = 50
# Override dangerous defaults that rewrite the partition table:
change-rules
reset

# Normal VGA console
# vga = normal
vga = {vga}
# End LILO global section
#
# BootSetup can be executed from a LiveCD. This means that lilo
# could be issued from a 'chrooted' Linux partition, which would
# happen to be the first Linux partition listed below.
# Therefore the following paths are relevant only when viewed
# from that 'chrooted' partition's perspective. Please take this
# constraint into consideration if you must modify this file
# or else BootSetup will fail.
#
# If later on you want to use this configuration file directly
# with lilo in a command line, use the following syntax:
# "lilo -v -C /etc/bootsetup/lilo.conf" instead of the traditional
# "lilo -v" command. You must of course issue that command from
# the operating system holding /etc/bootsetup/lilo.conf and ensure that
# all partitions referenced in it are mounted on the appropriate
# mountpoints.
"""

  def __init__(self, isTest):
    self.isTest = isTest
    self._prefix = "bootsetup.lilo-"
    self._tmp = tempfile.mkdtemp(prefix = self._prefix)
    sltl.mounting._tempMountDir = os.path.join(self._tmp, 'mounts')
    self.__debug("tmp dir = " + self._tmp)

  def __del__(self):
    if self._tmp and os.path.exists(self._tmp):
      self.__debug("cleanning " + self._tmp)
      try:
        cfgPath = self.getConfigurationPath()
        if os.path.exists(cfgPath):
          self.__debug("Remove " + cfgPath)
          os.remove(cfgPath)
        if os.path.exists(sltl.mounting._tempMountDir):
          self.__debug("Remove " + sltl.mounting._tempMountDir)
          os.rmdir(sltl.mounting._tempMountDir)
        self.__debug("Remove " + self._tmp)
        os.rmdir(self._tmp)
      except:
        pass

  def __debug(self, msg):
    if self.isTest:
      print "Debug: " + msg

  def getConfigurationPath(self):
    return os.path.join(self._tmp, "lilo.conf")

  def _mountBootPartition(self):
    """
    Return the mount point
    """
    self.__debug("bootPartition = " + self._bootPartition)
    if sltl.isMounted(self._bootPartition):
      self.__debug("bootPartition already mounted")
      return sltl.getMountPoint(self._bootPartition)
    else:
      self.__debug("bootPartition not mounted")
      return sltl.mountDevice(self._bootPartition)

  def _mountBootInBootPartition(self, mountPoint):
    # assume that if the mount_point is /, any /boot directory is already accessible/mounted
    if mountPoint != '/' and os.path.exists(os.path.join(mountPoint, 'etc/fstab')):
      self.__debug("mp != / and etc/fstab exists, will try to mount /boot by chrooting")
      try:
        self.__debug("grep -q /boot {mp}/etc/fstab && chroot {mp} /sbin/mount /boot".format(mp = mountPoint))
        if sltl.execCall("grep -q /boot {mp}/etc/fstab && chroot {mp} /sbin/mount /boot".format(mp = mountPoint)):
          self.__debug("/boot mounted in " + mp)
          self._bootInBootMounted = True
      except:
        pass

  def _mountPartitions(self):
    """
    Return a list of mount points for each partition
    """
    mountPointList = []
    if self._partitions:
      self.__debug("mount partitions: " + str(self._partitions))
      for p in self._partitions:
        dev = os.path.join("/dev", p[0])
        self.__debug("mount partition " + dev)
        mountPointList.append(sltl.mountDevice(dev))
    return mountPointList

  def _umountAll(self, mountPoint, mountPointList):
    self.__debug("umountAll")
    if mountPoint:
      self.__debug("umounting main mount point " + mountPoint)
      if self._bootInBootMounted:
        self.__debut("/boot mounted in " + mountPoint + ", so umount it")
        sltl.execCall("chroot {mp} /sbin/umount /boot".format(mp = mountPoint))
        self._bootInBootMounted = False
      if mountPointList:
        self.__debug("umount other mount points: " + str(mountPointList))
        for mp in mountPointList:
          self.__debug("umount " + str(mp))
          sltl.umountDevice(mp)
      if mountPoint != '/':
        self.__debug("main mount point ≠ '/' → umount " + mountPoint)
        sltl.umountDevice(mountPoint)

  def _createLiloSections(self, mountPointList):
    """
    Return a list of lilo section string for each partition.
    There could be more section than partitions if there are multiple kernels.
    """
    sections = []
    if self._partitions:
      for e in enumerate(self._partitions):
        i = e[0]
        p = e[1]
        mp = mountPointList[i]
        device = os.path.join("/dev", p[0])
        fs = p[1]
        bootType = p[2]
        label = p[3]
        if bootType == 'chain':
          sections.append(self._getChainLiloSection(device, label))
        elif bootType == 'linux':
          sections.extend(self._getLinuxLiloSections(device, fs, mp, label))
        else:
          sys.err.write("The boot type {type} is not supported.\n".format(type = bootType))
    return sections

  def _getChainLiloSection(self, device, label):
    """
    Returns a string for a chainloaded section
    """
    self.__debug("Section 'chain' for " + device + " with label: " + label)
    return """# {label} chain section
  other = {device}
  label = {label}
""".format(device = device, label = label)

  def _getLinuxLiloSections(self, device, fs, mp, label):
    """
    Returns a list of string sections, one for each kernel+initrd
    """
    sections = []
    self.__debug("Section 'linux' for " + device + "/" + fs + ", mounted on " + mp + " with label: " + label)
    kernelList = sorted(glob.glob("{mp}/boot/vmlinuz*".format(mp = mp)))
    initrdList = sorted(glob.glob("{mp}/boot/initr*".format(mp = mp)))
    for l in (kernelList, initrdList):
      for el in l:
        if os.path.isdir(el) or os.path.islink(el):
          l.remove(el)
    self.__debug("kernelList: " + str(kernelList))
    self.__debug("initrdList: " + str(initrdList))
    uuid = sltl.execGetOutput(['/sbin/blkid', '-s', 'UUID', '-o', 'value', device], shell = False)
    if uuid:
      rootDevice = "/dev/disk/by-uuid/{uuid}".format(uuid = uuid[0])
    else:
      rootDevice = device
    self.__debug("rootDevice = " + rootDevice)
    for (k, i, l) in self._getKernelInitrdCouples(kernelList, initrdList, label):
      self.__debug("kernel, initrd, label found: " + str(k) + "," + str(i) + "," + str(l))
      section = None
      if i:
        section = """# {label} Linux section
  root = {root}
  image = {image}
  initrd = {initrd}
""".format(image = k, initrd = i, root = rootDevice, label = l)
      else:
        section = """# {label} Linux section
  root = {root}
  image = {image}
""".format(image = k, root = rootDevice, label = l)
      if fs == 'ext4':
        section += '  append = "{append} "\n'.format(append = 'rootfstype=ext4')
      section += "  read-only\n  label = {label}\n".format(label = l)
      sections.append(section)
    return sections

  def _getKernelInitrdCouples(self, kernelList, initrdList, labelRef):
    ret = []
    if kernelList:
      if len(kernelList) == 1:
        initrd = None
        if initrdList:
          initrd = initrdList[0] # assume the only initrd match the only kernel
        ret.append([kernelList[0], initrd, labelRef])
      else:
        labelBase = labelRef[0:15-2] + "-"
        n = 0
        for kernel in kernelList:
          n += 1
          kernelSuffix = os.path.basename(kernel).replace("vmlinuz", "")
          initrd = None
          for i in initrdList:
            if kernelSuffix in i: # find the matching initrd
              initrd = i
              break
          ret.append((kernel, initrd, labelBase + str(n)))
    return ret

  def _getFrameBufferConf(self):
    """
    Return the frame buffer configuration for this hardware.
    Format: (fb, label)
    """
    try:
      fbGeometry = sltl.execGetOutput("/usr/sbin/fbset | grep -w geometry")
    except subprocess.CalledProcessorError:
      self.__debug("Impossible to determine frame buffer mode, default to text.")
      fbGeometry = None
    mode = None
    graphicMode = None
    if fbGeometry:
      vesaModes = {
          '320x200x4' :None, '640x400x4' :None, '640x480x4' :None, '800x500x4' :None, '800x600x4' : 770, '896x672x4' :None, '1024x640x4' :None, '1024x768x4' : 772, '1152x720x4' :None, '1280x800x4:' :None, '1280x1024x4' : 774, '1400x1050x4' :None, '1440x900x4' :None, '1600x1200x4' :None, '1920x1200x4' :None,
          '320x200x8' :None, '640x400x8' : 768, '640x480x8' : 769, '800x500x8' : 879, '800x600x8' : 771, '896x672x8' : 815, '1024x640x8' : 874, '1024x768x8' : 773, '1152x720x8' : 869, '1280x800x8:' : 864, '1280x1024x8' : 775, '1400x1050x8' : 796, '1440x900x8' : 864, '1600x1200x8' : 796, '1920x1200x8' : 893,
          '320x200x15': 781, '640x400x15': 801, '640x480x15': 784, '800x500x15': 880, '800x600x15': 787, '896x672x15': 816, '1024x640x15': 875, '1024x768x15': 790, '1152x720x15': 870, '1280x800x15:': 865, '1280x1024x15': 793, '1400x1050x15': 797, '1440x900x15': 865, '1600x1200x15': 797, '1920x1200x15': 894,
          '320x200x16': 782, '640x400x16': 802, '640x480x16': 785, '800x500x16': 881, '800x600x16': 788, '896x672x16': 817, '1024x640x16': 876, '1024x768x16': 791, '1152x720x16': 871, '1280x800x16:': 866, '1280x1024x16': 794, '1400x1050x16': 798, '1440x900x16': 866, '1600x1200x16': 798, '1920x1200x16': 895,
          '320x200x24': 783, '640x400x24': 803, '640x480x24': 786, '800x500x24': 882, '800x600x24': 789, '896x672x24': 818, '1024x640x24': 877, '1024x768x24': 792, '1152x720x24': 872, '1280x800x24:': 867, '1280x1024x24': 795, '1400x1050x24': 799, '1440x900x24': 867, '1600x1200x24': 799, '1920x1200x24': 896,
          '320x200x32':None, '640x400x32': 804, '640x480x32': 809, '800x500x32': 883, '800x600x32': 814, '896x672x32': 819, '1024x640x32': 878, '1024x768x32': 824, '1152x720x32': 873, '1280x800x32:': 868, '1280x1024x32': 829, '1400x1050x32': 834, '1440x900x32': 868, '1600x1200x32': 834, '1920x1200x32': 897,
          }
      values = fbGeometry[0].strip().split(' ')
      self.__debug("FB Values: " + str(values))
      xres = values[1]
      yres = values[2]
      deep = values[-1]
      graphicMode = "{x}x{y}x{d}".format(x = xres, y = yres, d = deep)
      if graphicMode in vesaModes:
        mode = vesaModes[graphicMode]
    if not mode:
      mode = 'normal'
      label = 'text'
    else:
      label = graphicMode
    return (mode, label)

  def createConfiguration(self, mbrDevice, bootPartition, partitions):
    """
    partitions format: [device, filesystem, boot type, label]
    """
    self._mbrDevice = os.path.join("/dev", mbrDevice)
    self._bootPartition = os.path.join("/dev", bootPartition)
    self._partitions = partitions
    mp = None
    mpList = None
    try:
      mp = self._mountBootPartition()
      self.__debug("mp = " + str(mp))
      self._mountBootInBootPartition(mp)
      mpList = self._mountPartitions()
      self.__debug("mount point lists: " + str(mpList))
      liloSections = self._createLiloSections(mpList)
      self.__debug("lilo sections: " + str(liloSections))
      (fb, fbLabel) = self._getFrameBufferConf()
      self.__debug("frame buffer mode = " + str(fb) + " " + str(fbLabel))
      f = open(self.getConfigurationPath(), "w")
      f.write(self._cfgTemplate.format(boot = self._mbrDevice, mp = mp, vga = "{0} # {1}".format(fb, fbLabel)))
      for s in liloSections:
        f.write(s)
        f.write("\n")
      f.close()
    finally:
      self._umountAll(mp, mpList)

  def install(self):
    """
    Assuming that last configuration editing didn't modified mount point.
    """
    if self._mbrDevice:
      self._bootInBootMounted = False
      mp = None
      mpList = None
      try:
        mp = self._mountBootPartition()
        self.__debug("mp = " + str(mp))
        self._mountBootInBootPartition(mp)
        if mp != "/":
          self.__debug("mount point ≠ / so mount /dev and /proc in it")
          # bind /dev and /proc in boot_partition
          sltl.execCall('mount -o bind /dev {mp}/dev'.format(mp = mp))
          sltl.execCall('mount -o bind /proc {mp}/proc'.format(mp = mp))
        mpList = self._mountPartitions()
        self.__debug("mount point lists: " + str(mpList))
        # copy the configuration to the boot_partition
        try:
          self.__debug("create etc/bootsetup directory in " + mp)
          os.makedirs(os.path.join(mp, 'etc/bootsetup'))
        except os.error:
          pass
        self.__debug("copy lilo.conf to etc/bootsetup")
        shutil.copyfile(self.getConfigurationPath(), os.path.join(mp, '/etc/bootsetup/lilo.conf'))
        # run lilo
        if self.isTest:
          self.__debug('/sbin/lilo -t -v -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
          sltl.execCall('/sbin/lilo -t -v -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
        else:
          sltl.execCall('/sbin/lilo -C {mp}/etc/bootsetup/lilo.conf'.format(mp = mp))
      finally:
        if mp and mp != "/":
          self.__debug("mount point ≠ / so umount /dev and /proc in it")
          sltl.execCall('umount {mp}/proc'.format(mp = mp))
          sltl.execCall('umount {mp}/dev'.format(mp = mp))
        self._umountAll(mp, mpList)
